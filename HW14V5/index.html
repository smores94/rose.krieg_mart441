<!DOCTYPE html>
<html>
<head>
    <title>3D Pinball Machine</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="./node_modules/cannon-es"></script>
    <script src="./node_modules/three/examples/jsm/controls/OrbitControls.js"></script>
    <script src="./node_modules/three"></script>
    <script src="./node_modules/howler"></script>
    <script>
        // SCENE SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);
        
        // CAMERA
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, -30);
        camera.lookAt(0, 0, 0);
        
        // RENDERER
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // CONTROLS (for debugging)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // PHYSICS WORLD
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -20, 0), // Stronger gravity for pinball
            allowSleep: true,
        });
        world.defaultContactMaterial.restitution = 0.7; // Bounciness
        
        // MATERIALS
        const tableMaterial = new CANNON.Material("table");
        const rubberMaterial = new CANNON.Material("rubber");
        const metalMaterial = new CANNON.Material("metal");
        
        // CONTACT MATERIALS
        world.addContactMaterial(
            new CANNON.ContactMaterial(rubberMaterial, tableMaterial, {
                restitution: 0.8,
                friction: 0.3,
            })
        );
        world.addContactMaterial(
            new CANNON.ContactMaterial(metalMaterial, tableMaterial, {
                restitution: 0.4,
                friction: 0.1,
            })
        );
        
        // LIGHTS
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // PINBALL TABLE
        const tableWidth = 20;
        const tableHeight = 1;
        const tableDepth = 40;
        const tableGeo = new THREE.BoxGeometry(tableWidth, tableHeight, tableDepth);
        const tableMat = new THREE.MeshStandardMaterial({
            color: 0x226622,
            roughness: 0.8,
            metalness: 0.2,
        });
        const tableMesh = new THREE.Mesh(tableGeo, tableMat);
        tableMesh.receiveShadow = true;
        tableMesh.position.y = -tableHeight / 2;
        scene.add(tableMesh);
        
        const tableBody = new CANNON.Body({
            mass: 0, // Static
            shape: new CANNON.Box(new CANNON.Vec3(tableWidth / 2, tableHeight / 2, tableDepth / 2)),
            material: tableMaterial,
        });
        tableBody.position.copy(tableMesh.position);
        world.addBody(tableBody);
        
        // TABLE WALLS
        const wallHeight = 5;
        const wallThickness = 0.5;
        
        const createWall = (x, z, width, depth, rotation = 0) => {
            const wallGeo = new THREE.BoxGeometry(width, wallHeight, depth);
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.7,
                metalness: 0.3,
            });
            const wallMesh = new THREE.Mesh(wallGeo, wallMat);
            wallMesh.position.set(x, wallHeight / 2 - tableHeight, z);
            wallMesh.rotation.y = rotation;
            wallMesh.castShadow = true;
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);
            
            const wallBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(width / 2, wallHeight / 2, depth / 2)),
                material: metalMaterial,
                position: new CANNON.Vec3(x, wallHeight / 2 - tableHeight, z),
            });
            wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotation);
            world.addBody(wallBody);
            
            return { mesh: wallMesh, body: wallBody };
        };
        
        // Side walls
        createWall(0, tableDepth / 2 - wallThickness / 2, tableWidth, wallThickness); // Back
        createWall(0, -tableDepth / 2 + wallThickness / 2, tableWidth, wallThickness); // Front
        createWall(tableWidth / 2 - wallThickness / 2, 0, wallThickness, tableDepth); // Right
        createWall(-tableWidth / 2 + wallThickness / 2, 0, wallThickness, tableDepth); // Left
        
        // Angled flipper walls
        const flipperWallLength = 8;
        createWall(
            tableWidth / 2 - wallThickness - 3,
            -tableDepth / 2 + wallThickness + 4,
            wallThickness,
            flipperWallLength,
            Math.PI / 4
        );
        createWall(
            -tableWidth / 2 + wallThickness + 3,
            -tableDepth / 2 + wallThickness + 4,
            wallThickness,
            flipperWallLength,
            -Math.PI / 4
        );
        
        // PINBALL
        const ballRadius = 0.5;
        const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            roughness: 0.1,
            metalness: 0.9,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
        });
        const ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true;
        ballMesh.receiveShadow = true;
        scene.add(ballMesh);
        
        const ballBody = new CANNON.Body({
            mass: 1,
            shape: new CANNON.Sphere(ballRadius),
            material: rubberMaterial,
            position: new CANNON.Vec3(0, 5, tableDepth / 2 - 5),
            linearDamping: 0.01,
            angularDamping: 0.1,
        });
        world.addBody(ballBody);
        
        // FLIPPERS
        const createFlipper = (x, z, angle, side) => {
            const flipperLength = 5;
            const flipperWidth = 1.5;
            const flipperThickness = 1;
            
            const flipperGeo = new THREE.BoxGeometry(flipperLength, flipperThickness, flipperWidth);
            const flipperMat = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.3,
                metalness: 0.8,
            });
            const flipperMesh = new THREE.Mesh(flipperGeo, flipperMat);
            flipperMesh.position.set(x, flipperThickness / 2, z);
            flipperMesh.rotation.y = angle;
            flipperMesh.castShadow = true;
            flipperMesh.receiveShadow = true;
            scene.add(flipperMesh);
            
            const hingePos = new CANNON.Vec3(
                x - (flipperLength / 2 - 0.5) * Math.sin(angle),
                0,
                z - (flipperLength / 2 - 0.5) * Math.cos(angle)
            );
            
            const flipperBody = new CANNON.Body({
                mass: 3,
                shape: new CANNON.Box(new CANNON.Vec3(flipperLength / 2, flipperThickness / 2, flipperWidth / 2)),
                material: metalMaterial,
                position: new CANNON.Vec3(x, flipperThickness / 2, z),
                angularDamping: 0.5,
            });
            flipperBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
            world.addBody(flipperBody);
            
            // Hinge constraint
            const hinge = new CANNON.HingeConstraint(
                tableBody,
                flipperBody,
                {
                    pivotA: new CANNON.Vec3(hingePos.x, hingePos.y, hingePos.z),
                    pivotB: new CANNON.Vec3(-flipperLength / 2 + 0.5, 0, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                }
            );
            world.addConstraint(hinge);
            
            // Motor
            const motorSpeed = side === 'left' ? -15 : 15;
            const motorMaxForce = 50;
            
            return {
                mesh: flipperMesh,
                body: flipperBody,
                hinge: hinge,
                motorSpeed: motorSpeed,
                motorMaxForce: motorMaxForce,
                angle: angle,
                restAngle: angle,
                active: false,
            };
        };
        
        const leftFlipper = createFlipper(-5, -tableDepth / 2 + 3, -Math.PI / 6, 'left');
        const rightFlipper = createFlipper(5, -tableDepth / 2 + 3, Math.PI / 6, 'right');
        
        // BUMPERS
        const createBumper = (x, z) => {
            const bumperRadius = 1.5;
            const bumperGeo = new THREE.SphereGeometry(bumperRadius, 32, 32);
            const bumperMat = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5,
                roughness: 0.1,
                metalness: 0.5,
            });
            const bumperMesh = new THREE.Mesh(bumperGeo, bumperMat);
            bumperMesh.position.set(x, bumperRadius, z);
            bumperMesh.castShadow = true;
            bumperMesh.receiveShadow = true;
            scene.add(bumperMesh);
            
            const bumperBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Sphere(bumperRadius),
                material: rubberMaterial,
                position: new CANNON.Vec3(x, bumperRadius, z),
            });
            world.addBody(bumperBody);
            
            // Add light
            const light = new THREE.PointLight(0xffff00, 1, 5);
            light.position.set(x, bumperRadius + 1, z);
            scene.add(light);
            
            return { mesh: bumperMesh, body: bumperBody, light: light };
        };
        
        const bumpers = [
            createBumper(0, 0),
            createBumper(-5, 5),
            createBumper(5, 5),
        ];
        
        // PLUNGER
        const createPlunger = () => {
            const plungerRadius = 0.7;
            const plungerHeight = 3;
            const plungerGeo = new THREE.CylinderGeometry(
                plungerRadius,
                plungerRadius,
                plungerHeight,
                32
            );
            const plungerMat = new THREE.MeshStandardMaterial({
                color: 0x3333ff,
                roughness: 0.3,
                metalness: 0.7,
            });
            const plungerMesh = new THREE.Mesh(plungerGeo, plungerMat);
            plungerMesh.position.set(0, plungerHeight / 2, tableDepth / 2 - 1);
            plungerMesh.rotation.z = Math.PI / 2;
            plungerMesh.castShadow = true;
            plungerMesh.receiveShadow = true;
            scene.add(plungerMesh);
            
            const plungerBody = new CANNON.Body({
                mass: 2,
                shape: new CANNON.Cylinder(
                    plungerRadius,
                    plungerRadius,
                    plungerHeight,
                    20
                ),
                material: metalMaterial,
                position: new CANNON.Vec3(0, plungerHeight / 2, tableDepth / 2 - 1),
            });
            plungerBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), Math.PI / 2);
            world.addBody(plungerBody);
            
            // Constraint for sliding
            const constraint = new CANNON.PointToPointConstraint(
                plungerBody,
                new CANNON.Vec3(0, 0, 0),
                tableBody,
                new CANNON.Vec3(0, plungerHeight / 2, tableDepth / 2 - 1),
                1
            );
            world.addConstraint(constraint);
            
            return {
                mesh: plungerMesh,
                body: plungerBody,
                constraint: constraint,
                restPosition: new CANNON.Vec3(0, plungerHeight / 2, tableDepth / 2 - 1),
                pulledPosition: new CANNON.Vec3(0, plungerHeight / 2, tableDepth / 2 - 3),
                isPulled: false,
            };
        };
        
        const plunger = createPlunger();
        
        // SOUNDS
        const sounds = {
            bumper: new Howl({ src: ['https://assets.codepen.io/21542/howler-pinball-bumper.mp3'] }),
            flipper: new Howl({ src: ['https://assets.codepen.io/21542/howler-pinball-flipper.mp3'] }),
            plunger: new Howl({ src: ['https://assets.codepen.io/21542/howler-pinball-plunger.mp3'] }),
            wall: new Howl({ src: ['https://assets.codepen.io/21542/howler-pinball-wall.mp3'] }),
        };
        
        // SCORE
        let score = 0;
        const scoreElement = document.createElement('div');
        scoreElement.style.position = 'absolute';
        scoreElement.style.top = '20px';
        scoreElement.style.left = '20px';
        scoreElement.style.color = 'white';
        scoreElement.style.fontFamily = 'Arial';
        scoreElement.style.fontSize = '24px';
        scoreElement.textContent = `Score: ${score}`;
        document.body.appendChild(scoreElement);
        
        // CONTROLS
        const keys = {
            leftFlipper: false,
            rightFlipper: false,
            plunger: false,
        };
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keys.leftFlipper = true;
            if (e.code === 'ArrowRight') keys.rightFlipper = true;
            if (e.code === 'Space') keys.plunger = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.leftFlipper = false;
            if (e.code === 'ArrowRight') keys.rightFlipper = false;
            if (e.code === 'Space') keys.plunger = false;
        });
        
        // COLLISION DETECTION
        world.addEventListener('postStep', () => {
            // Check ball collisions with bumpers
            for (const bumper of bumpers) {
                if (world.narrowphase.contactEquations.some(contact => {
                    return (
                        (contact.bi === ballBody && contact.bj === bumper.body) ||
                        (contact.bj === ballBody && contact.bi === bumper.body)
                    );
                })) {
                    bumper.light.intensity = 5;
                    setTimeout(() => (bumper.light.intensity = 1), 100);
                    sounds.bumper.play();
                    score += 100;
                    scoreElement.textContent = `Score: ${score}`;
                }
            }
        });
        
        // GAME LOOP
        const clock = new THREE.Clock();
        let lastTime = 0;
        
        function animate() {
            const time = clock.getElapsedTime();
            const deltaTime = time - lastTime;
            lastTime = time;
            
            // Update physics
            world.step(1 / 60, deltaTime, 3);
            
            // Sync Three.js objects with Cannon.js bodies
            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);
            
            leftFlipper.mesh.position.copy(leftFlipper.body.position);
            leftFlipper.mesh.quaternion.copy(leftFlipper.body.quaternion);
            
            rightFlipper.mesh.position.copy(rightFlipper.body.position);
            rightFlipper.mesh.quaternion.copy(rightFlipper.body.quaternion);
            
            plunger.mesh.position.copy(plunger.body.position);
            plunger.mesh.quaternion.copy(plunger.body.quaternion);
            
            // Handle controls
            if (keys.leftFlipper && !leftFlipper.active) {
                leftFlipper.hinge.enableMotor();
                leftFlipper.hinge.setMotorSpeed(leftFlipper.motorSpeed);
                leftFlipper.hinge.setMotorMaxForce(leftFlipper.motorMaxForce);
                leftFlipper.active = true;
                sounds.flipper.play();
            } else if (!keys.leftFlipper && leftFlipper.active) {
                leftFlipper.hinge.disableMotor();
                leftFlipper.active = false;
            }
            
            if (keys.rightFlipper && !rightFlipper.active) {
                rightFlipper.hinge.enableMotor();
                rightFlipper.hinge.setMotorSpeed(rightFlipper.motorSpeed);
                rightFlipper.hinge.setMotorMaxForce(rightFlipper.motorMaxForce);
                rightFlipper.active = true;
                sounds.flipper.play();
            } else if (!keys.rightFlipper && rightFlipper.active) {
                rightFlipper.hinge.disableMotor();
                rightFlipper.active = false;
            }
            
            if (keys.plunger && !plunger.isPulled) {
                plunger.body.position.z = plunger.pulledPosition.z;
                plunger.isPulled = true;
            } else if (!keys.plunger && plunger.isPulled) {
                plunger.body.position.z = plunger.restPosition.z;
                ballBody.applyImpulse(
                    new CANNON.Vec3(0, 0, -30),
                    new CANNON.Vec3(0, 0, 0)
                );
                plunger.isPulled = false;
                sounds.plunger.play();
            }
            
            // Reset ball if it falls off
            if (ballBody.position.y < -10) {
                ballBody.position.set(0, 5, tableDepth / 2 - 5);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }
            
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>