/**
 * Chromata.js - Image to Particle Animation Library */

(function(window) {
    'use strict';

    // Utility functions
    const Utils = {
        indexToRgbString: function(index) {
            return index % 3 == 0 ? "#0000ff" : index % 2 == 0 ? "#00ff00" : "#ff0000";
        },

        getImageArray: function(context) {
            const width = context.canvas.width;
            const height = context.canvas.height;
            const imageData = context.getImageData(0, 0, width, height);
            const array = [];

            for (let y = 0; y < height; y++) {
                array.push([]);
                for (let x = 0; x < width; x++) {
                    const pixel = [];
                    const offset = (y * width + x) * 4;
                    for (let i = 0; i < 4; i++) {
                        pixel.push(imageData.data[offset + i]);
                    }
                    array[y].push(pixel);
                }
            }
            return array;
        },

        getWorkingArray: function(context) {
            const width = context.canvas.width;
            const height = context.canvas.height;
            const array = [];

            for (let y = 0; y < height; y++) {
                array.push([]);
                for (let x = 0; x < width; x++) {
                    array[y].push([false, false, false]);
                }
            }
            return array;
        },

        getOutputDimensions: function(image, sizeOption) {
            if (sizeOption === 'original') {
                return { width: image.width, height: image.height };
            }

            const parent = image.parentNode;
            const widthRatio = parent.clientWidth / image.width;
            const heightRatio = parent.clientHeight / image.height;
            const scale = Math.min(widthRatio, heightRatio);

            return {
                width: image.width * scale,
                height: image.height * scale
            };
        }
    };

    // Circular buffer for path tracking
    class PathQueue {
        constructor(size) {
            this.queue = [];
            this.size = size;
        }

        put(point) {
            this.queue.push(point);
            if (this.queue.length > this.size) {
                this.queue.shift();
            }
        }

        get(index = 0) {
            if (index >= 0 && index < this.queue.length) {
                return this.queue[index];
            }
            if (index < 0 && Math.abs(index) <= this.queue.length) {
                return this.queue[this.queue.length + index];
            }
            return undefined;
        }

        contains(point) {
            return this.queue.some(p => p[0] === point[0] && p[1] === point[1]);
        }
    }

    // Path finder for particle movement
    class PathFinder {
        constructor(pixelArray, workingArray, color, x = 0, y = 0, options = {}) {
            this.pixelArray = pixelArray;
            this.workingArray = workingArray;
            this.arrayWidth = pixelArray[0].length;
            this.arrayHeight = pixelArray.length;
            this.x = Math.round(x);
            this.y = Math.round(y);
            this.options = options;
            this.pathQueue = new PathQueue(10);
            this.velocity = options.startingVelocity;
            
            this.targetColor = typeof color === 'string' ? this.hexToRgb(color) : color;
            this.rgbIndex = this.getRgbIndex(this.targetColor);
            
            this.comparatorFn = options.key === 'low' 
                ? (val, ref) => val > 0 && val < ref 
                : (val, ref) => ref < val && val < 255;
        }

        getNextPoint() {
            let point, attempts = 0;
            do {
                point = this.findNextPixel();
                attempts++;
            } while (attempts <= 5 && !point.isPristine);
            
            return point.nextPixel;
        }

        findNextPixel() {
            const angle = this.getVelocityAngle();
            const speed = Math.round(Math.sqrt(
                this.velocity[0] ** 2 + this.velocity[1] ** 2
            ));
            
            let bestPixel = null;
            let bestValue = this.options.key === 'low' ? 100000 : 0;
            
            // Search in possible directions
            for (let a = angle - this.options.turningAngle/2, i = -2; 
                 a <= angle + this.options.turningAngle/2; 
                 a += this.options.turningAngle/4, i++) {
                
                const x = this.x + Math.round(speed * Math.cos(a));
                const y = this.y + Math.round(speed * Math.sin(a));
                
                if (!this.isInRange(x, y)) continue;
                
                const pixelValue = this.workingArray[y][x][this.rgbIndex];
                const sourcePixel = this.pixelArray[y][x];
                const alpha = sourcePixel[3];
                const distance = this.getColorDistance(sourcePixel);
                
                if (this.comparatorFn(distance, bestValue) && !pixelValue && alpha === 255) {
                    bestPixel = [x, y, 255 - distance];
                    bestValue = distance;
                }
                
                // Fallback to previous path if no good pixel found
                if (i ===