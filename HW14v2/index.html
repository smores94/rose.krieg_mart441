<!DOCTYPE html>
<html>
<head>
    <title>3D Pinball Machine</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

    <script>
        // SCENE SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);
        
        // CAMERA
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, -30);
        camera.lookAt(0, 0, 0);
        
        // RENDERER
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // CONTROLS
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // PHYSICS WORLD
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -20, 0),
            allowSleep: true,
        });
        world.defaultContactMaterial.restitution = 0.7;
        
        // MATERIALS
        const tableMaterial = new CANNON.Material("table");
        const rubberMaterial = new CANNON.Material("rubber");
        const metalMaterial = new CANNON.Material("metal");
        
        // CONTACT MATERIALS
        world.addContactMaterial(
            new CANNON.ContactMaterial(rubberMaterial, tableMaterial, {
                restitution: 0.8,
                friction: 0.3,
            })
        );
        world.addContactMaterial(
            new CANNON.ContactMaterial(metalMaterial, tableMaterial, {
                restitution: 0.4,
                friction: 0.1,
            })
        );
        
        // LIGHTS
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // TABLE
        const tableWidth = 20;
        const tableHeight = 1;
        const tableDepth = 40;
        const tableGeo = new THREE.BoxGeometry(tableWidth, tableHeight, tableDepth);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x226622 });
        const tableMesh = new THREE.Mesh(tableGeo, tableMat);
        tableMesh.receiveShadow = true;
        tableMesh.position.y = -tableHeight / 2;
        scene.add(tableMesh);
        
        const tableBody = new CANNON.Body({
            mass: 0,
            shape: new CANNON.Box(new CANNON.Vec3(tableWidth / 2, tableHeight / 2, tableDepth / 2)),
            material: tableMaterial,
        });
        tableBody.position.copy(tableMesh.position);
        world.addBody(tableBody);
        
        // WALLS
        const createWall = (x, z, width, depth, rotation = 0) => {
            const wallHeight = 5;
            const wallGeo = new THREE.BoxGeometry(width, wallHeight, depth);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const wallMesh = new THREE.Mesh(wallGeo, wallMat);
            wallMesh.position.set(x, wallHeight / 2 - tableHeight, z);
            wallMesh.rotation.y = rotation;
            wallMesh.castShadow = true;
            scene.add(wallMesh);
            
            const wallBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(width / 2, wallHeight / 2, depth / 2)),
                material: metalMaterial,
                position: new CANNON.Vec3(x, wallHeight / 2 - tableHeight, z),
            });
            wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotation);
            world.addBody(wallBody);
        };
        
        // Create walls
        createWall(0, tableDepth / 2 - 0.25, tableWidth, 0.5); // Back
        createWall(0, -tableDepth / 2 + 0.25, tableWidth, 0.5); // Front
        createWall(tableWidth / 2 - 0.25, 0, 0.5, tableDepth); // Right
        createWall(-tableWidth / 2 + 0.25, 0, 0.5, tableDepth); // Left
        
        // BALL
        const ballRadius = 0.5;
        const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const ballMesh = new THREE.Mesh(ballGeo, ballMat);
        ballMesh.castShadow = true;
        scene.add(ballMesh);
        
        const ballBody = new CANNON.Body({
            mass: 1,
            shape: new CANNON.Sphere(ballRadius),
            material: rubberMaterial,
            position: new CANNON.Vec3(0, 5, tableDepth / 2 - 5),
        });
        world.addBody(ballBody);
        
        // FLIPPERS
        const createFlipper = (side) => {
            const flipperLength = 5;
            const flipperGeo = new THREE.BoxGeometry(flipperLength, 1, 2);
            const flipperMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
            const flipperMesh = new THREE.Mesh(flipperGeo, flipperMat);
            scene.add(flipperMesh);
            
            const flipperBody = new CANNON.Body({
                mass: 3,
                shape: new CANNON.Box(new CANNON.Vec3(flipperLength / 2, 0.5, 1)),
                material: metalMaterial,
            });
            world.addBody(flipperBody);
            
            const hingePos = new CANNON.Vec3(
                side === 'left' ? -tableWidth / 2 + 1 : tableWidth / 2 - 1,
                0.5,
                -tableDepth / 2 + 3
            );
            
            const hinge = new CANNON.HingeConstraint(tableBody, flipperBody, {
                pivotA: hingePos,
                pivotB: new CANNON.Vec3(0, 0, 0),
                axisA: new CANNON.Vec3(0, 1, 0),
                axisB: new CANNON.Vec3(0, 1, 0),
            });
            world.addConstraint(hinge);
            
            return {
                mesh: flipperMesh,
                body: flipperBody,
                hinge: hinge,
                motorSpeed: side === 'left' ? -15 : 15,
                active: false
            };
        };
        
        const leftFlipper = createFlipper('left');
        const rightFlipper = createFlipper('right');
        
        // MOUSE INTERACTION
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        document.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([tableMesh, ballMesh]);
            
            if (intersects.length > 0) {
                ballBody.applyImpulse(new CANNON.Vec3(0, 5, -5));
            }
        });
        
        // KEYBOARD CONTROLS
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') {
                leftFlipper.hinge.enableMotor();
                leftFlipper.hinge.setMotorSpeed(leftFlipper.motorSpeed);
            }
            if (e.code === 'ArrowRight') {
                rightFlipper.hinge.enableMotor();
                rightFlipper.hinge.setMotorSpeed(rightFlipper.motorSpeed);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') leftFlipper.hinge.disableMotor();
            if (e.code === 'ArrowRight') rightFlipper.hinge.disableMotor();
        });
        
        // GAME LOOP
        function animate() {
            requestAnimationFrame(animate);
            
            // Update physics
            world.step(1/60);
            
            // Sync objects
            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);
            
            leftFlipper.mesh.position.copy(leftFlipper.body.position);
            leftFlipper.mesh.quaternion.copy(leftFlipper.body.quaternion);
            
            rightFlipper.mesh.position.copy(rightFlipper.body.position);
            rightFlipper.mesh.quaternion.copy(rightFlipper.body.quaternion);
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // START
        animate();
    </script>
</body>
</html>